ggplot(aes(x=total_officer_deaths, y = total_inmate_deaths)) + geom_point() +
labs(x = "Total Officer Deaths", y = "Inmate Deaths")
p5 <- systems %>%
ggplot(aes(x=inmate_tests, y = total_inmate_deaths)) + geom_point() +
labs(x = "Inmate Tests", y = "Inmate Deaths")
p6 <- systems %>%
ggplot(aes(x=state_deaths, y = total_inmate_deaths)) + geom_point() +
labs(x = "State Deaths", y = "Inmate Deaths")
p7 <- systems %>%
ggplot(aes(x=state_cases, y = total_inmate_deaths)) + geom_point() +
labs(x = "State Cases", y = "Inmate Deaths")
grid.arrange(p1, p2, p3, p4, p5, p6, p7, ncol=2)
sys.data.only <- systems %>%
select(-c("system"))
flat.prior <- stan_glm(data = sys.data.only, formula = total_inmate_deaths~., prior=NULL,
family= gaussian(),
refresh = 0, refresh = 0, seed = 1)
posterior.flat.prior <- as.matrix(flat.prior)
mcmc_areas(posterior.flat.prior, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(flat.prior$y),
yrep = posterior_predict(flat.prior, draws = 50))
normal.prior <- stan_glm(data = sys.data.only, formula = total_inmate_deaths~., prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 2)
posterior.normal.prior <- as.matrix(normal.prior)
mcmc_areas(posterior.normal.prior, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.prior$y),
yrep = posterior_predict(normal.prior, draws = 50))
normal.full1 <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_inmate_cases + latest_inmate_population+
total_officer_cases+ total_officer_deaths+
state_cases+ state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.normal.full1 <- as.matrix(normal.full1)
mcmc_areas(posterior.normal.full1, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.full1$y),
yrep = posterior_predict(normal.full1, draws = 50))
round(posterior_interval(normal.full1, prob = 0.90), 3)
normal.full2 <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths +
latest_inmate_population) +
total_inmate_cases*(latest_inmate_population + total_officer_cases
+ total_officer_deaths + state_cases + state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.normal.full2 <- as.matrix(normal.full1)
mcmc_areas(posterior.normal.full2, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.full2$y),
yrep = posterior_predict(normal.full2, draws = 50))
round(posterior_interval(normal.full2, prob = 0.90), 3)
normal.full3 <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths +
latest_inmate_population) +
total_inmate_cases*(latest_inmate_population + state_cases) +
latest_inmate_population*(total_officer_cases + total_officer_deaths +
state_cases + state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.normal.full3 <- as.matrix(normal.full3)
mcmc_areas(posterior.normal.full3, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.full3$y),
yrep = posterior_predict(normal.full3, draws = 50))
round(posterior_interval(normal.full3, prob = 0.90), 3)
normal.full4 <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths +
latest_inmate_population) +
total_inmate_cases*(latest_inmate_population + state_cases) +
latest_inmate_population*(state_deaths) +
total_officer_cases*(total_officer_deaths + state_cases + state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.normal.full4 <- as.matrix(normal.full3)
mcmc_areas(posterior.normal.full4, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.full4$y),
yrep = posterior_predict(normal.full4, draws = 50))
round(posterior_interval(normal.full4, prob = 0.90), 3)
normal.full5 <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths +
latest_inmate_population) +
total_inmate_cases*(latest_inmate_population + state_cases) +
latest_inmate_population*(state_deaths) +
total_officer_cases*(state_deaths) +
total_officer_deaths*(state_cases + state_deaths) +
state_cases*(state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.normal.full5 <- as.matrix(normal.full5)
mcmc_areas(posterior.normal.full5, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(normal.full5$y),
yrep = posterior_predict(normal.full5, draws = 50))
round(posterior_interval(normal.full5, prob = 0.90), 3)
loo.ints <- loo(normal.full5, save_psis = T)
loo.main <- loo(normal.prior, save_psis = T)
loo_compare(loo.ints, loo.main)
sig.model <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths +
latest_inmate_population) +
total_inmate_cases*(latest_inmate_population + state_cases) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.sig.model <- as.matrix(sig.model)
mcmc_areas(posterior.sig.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(sig.model$y),
yrep = posterior_predict(sig.model, draws = 50))
round(posterior_interval(sig.model, prob = 0.90), 3)
sig2.model <- stan_glm(data = sys.data.only,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.sig2.model <- as.matrix(sig2.model)
mcmc_areas(posterior.sig2.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(sig2.model$y),
yrep = posterior_predict(sig2.model, draws = 50))
round(posterior_interval(sig2.model, prob = 0.90), 3)
loo.ints <- loo(sig2.model, save_psis = T)
loo.main <- loo(normal.prior, save_psis = T)
loo_compare(loo.ints, loo.main)
loo.ints
loo.main
plot(loo.ints, label_points=TRUE)
plot(loo.main, label_points=TRUE)
us_excess_deaths <- read_csv("../excess-deaths/excess_death_us_only.csv")
excess_deaths <- us_excess_deaths %>%
select(-c("Suppress", "Note")) %>%
filter(Year > 2019)
excess_deaths$`Week Ending Date` <- as.Date(excess_deaths$`Week Ending Date`)
state_excess_deaths <- excess_deaths %>%
group_by(State)
num_excess_total <- state_excess_deaths %>%
summarise(excess = sum(`Exceeds Threshold`))
state_excess_deaths %>%
filter(`Week Ending Date` > "0004-01-20")
state_excess_deaths <- excess_deaths %>%
group_by(State)
num_excess_total <- state_excess_deaths %>%
summarise(excess = sum(`Exceeds Threshold`))
state_excess_deaths %>%
filter(`Week Ending Date` > "0004-01-20") %>%
summarise(excess = sum(`Exceeds Threshold`))
state_excess_deaths <- excess_deaths %>%
group_by(State)
num_excess_total <- state_excess_deaths %>%
summarise(excess = sum(`Exceeds Threshold`))
pre_april_excess_deaths <- state_excess_deaths %>%
filter(`Week Ending Date` > "0004-01-20") %>%
summarise(excess = sum(`Exceeds Threshold`))
state_excess_deaths <- excess_deaths %>%
group_by(State)
num_excess_total <- state_excess_deaths %>%
summarise(total_excess = sum(`Exceeds Threshold`))
pre_april_excess_deaths <- state_excess_deaths %>%
filter(`Week Ending Date` > "0004-01-20") %>%
summarise(pre_april_excess = sum(`Exceeds Threshold`))
systems <- systems %>%
inner_join(num_excess_total,by=c("system" = "State")) %>%
inner_join(pre_april_excess_deaths,by=c("system" = "State"))
knitr::opts_chunk$set(echo = TRUE)
library(plyr)
library(magrittr)
library(readr)
library(tidyverse)
library(gridExtra)
library(rstan)
library(bayesplot)
library(loo)
library(rstanarm)
library(bayestestR)
mask_use <- read_csv(file="../mask-use/mask-use-by-county.csv")
cases_recent <- read_csv(file="../us-states.csv")
prison_facilities <- read_csv(file="../prisons/facilities.csv")
systems <- read.csv(file="../prisons/systems.csv")
state.cases <- cases_recent %>%
filter(date == "2021-03-31") %>%
select(-c("date", "fips"))
# drop unimportant columns & add overall state data
systems <- systems %>%
inner_join(state.cases,by=c("system" = "state")) %>%
select(-c(max_inmate_population_2020))
# rename state data columns
colnames(systems)[8] <- "state_cases"
colnames(systems)[9] <- "state_deaths"
# drop NA's
systems <- drop_na(systems)
# save unscaled data as sep. dataset
systems.us <- systems
# scale numerical values
systems$latest_inmate_population <- scale(systems$latest_inmate_population)
systems$total_inmate_cases <- scale(systems$total_inmate_cases)
systems$total_inmate_deaths <- scale(systems$total_inmate_deaths)
systems$total_officer_cases <- scale(systems$total_officer_cases)
systems$total_officer_deaths <- scale(systems$total_officer_deaths)
systems$inmate_tests <- scale(systems$inmate_tests)
systems$state_cases <- scale(systems$state_cases)
systems$state_deaths <- scale(systems$state_deaths)
# drop unimportant columns & add overall state data
systems <- systems %>%
inner_join(state.cases,by=c("system" = "state")) %>%
select(-c(max_inmate_population_2020))
sys.copy <- systems
sys.copy <- systems
sys.copy <- inner_join(sys.copy, num_excess_total, by=c("system" = "State"))
sys.copy
sys.copy <- systems
sys.copy <- inner_join(sys.copy, num_excess_total, by=c("system" = "State"))
sys.copy <- inner_join(sys.copy, pre_april_excess_deaths, by=c("system" = "State"))
sys.copy <- systems
sys.copy <- inner_join(sys.copy, num_excess_total, by=c("system" = "State"))
sys.copy <- inner_join(sys.copy, pre_april_excess_deaths, by=c("system" = "State"))
sys.copy$total_excess <- scale(sys.copy$total_excess)
sys.copy$pre_april_excess <- scale(sys.copy$pre_april_excess)
sys.copy.data <- select(sys.copy, -c("system"))
excess1.model <- stan_glm(data = sys.copy.data,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths) + total_excess + pre_april_excess,
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.sig2.model <- as.matrix(sig2.model)
mcmc_areas(posterior.sig2.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(sig2.model$y),
yrep = posterior_predict(sig2.model, draws = 50))
excess1.model <- stan_glm(data = sys.copy.data,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths) + total_excess + pre_april_excess,
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.excess1.model <- as.matrix(excess1.model)
mcmc_areas(posterior.excess1.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(excess1.model$y),
yrep = posterior_predict(excess1.model, draws = 50))
excess2.model <- stan_glm(data = sys.copy.data,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths) +
total_excess * (inmate_tests + total_officer_deaths + latest_inmate_population +
state_deaths + state_cases + pre_april_excess) +
pre_april_excess * (inmate_tests + total_officer_deaths + latest_inmate_population +
state_deaths + state_cases),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 6)
posterior.excess2.model <- as.matrix(excess2.model)
mcmc_areas(posterior.excess2.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(excess2.model$y),
yrep = posterior_predict(excess2.model, draws = 50))
round(posterior_interval(excess2.model, prob = 0.90), 3)
View(sys.copy)
excess3.model <- stan_glm(data = sys.copy.data,
formula = total_inmate_deaths~.,
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 6)
posterior.excess3.model <- as.matrix(excess3.model)
mcmc_areas(posterior.excess3.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(excess3.model$y),
yrep = posterior_predict(excess3.model, draws = 50))
round(posterior_interval(excess3.model, prob = 0.90), 3)
View(sys.copy)
sys.complete <- systems %>%
filter(system != "Montana" & system != "Arkansas" & system != "Nevada" & system != "Oklahoma")
sys.complete <- systems %>%
filter(system != "Montana" & system != "Arkansas" & system != "Nevada" & system != "Oklahoma")
sys.complete.data <- select(sys.complete, -c("system"))
sig.complete.model <- stan_glm(data = sys.complete.data,
formula = total_inmate_deaths~ inmate_tests*(total_officer_deaths) +
latest_inmate_population*(state_deaths) +
state_cases*(state_deaths),
prior=normal(0,1),
family= gaussian(),
refresh = 0, refresh = 0, seed = 4)
posterior.sig.complete.model <- as.matrix(sig.complete.model)
mcmc_areas(posterior.sig.complete.model, prob=0.90)
color_scheme_set("red")
ppc_dens_overlay(y = as.vector(sig.complete.model$y),
yrep = posterior_predict(sig.complete.model, draws = 50))
round(posterior_interval(sig.complete.model, prob = 0.90), 3)
(loo1 <- loo(sig2.model, save_psis = T))
(loo2 <- loo(sig.complete.model, save_psis = T))
loo_compare(loo1, loo2)
(loo1 <- loo(sig2.model, save_psis = T))
(loo2 <- loo(sig.complete.model, save_psis = T))
library(see)
install.packages("see")
library(see)
library(see)
BF <- bayesfactor_parameters(sig2.model, prior=normal(0,1), null=0,
direction = "two-sided")
library(see)
BF <- bayesfactor_parameters(sig2.model, prior=normal(0,1),
direction = "two-sided")
library(see)
BF <- bayesfactor_parameters(sig2.model, null=0,
direction = "two-sided")
plot(BF)
install.packages("modelbased")
library(modelbased)
estimate_contrasts(sig2.model, test = "bf")
?estimate_contrasts
library(modelbased)
estimate_contrasts(sig2.model, test = "bf", levels=sig2.model$terms)
library(modelbased)
estimate_contrasts(sig2.model, test = "bf", levels=sig2.model$terms["dimnames"][2])
library(modelbased)
estimate_contrasts(sig2.model, test = "bf", levels=sig2.model$terms)
lm.gprior <- function(y, X, g, nu0, gamma_sq0, S)
{
# sample new model
n = dim(X)[1]
p = dim(X)[2]
# sample sigma^2
nu.st = nu0 + n
Hg = (g/(g+1)) * X%*%solve(t(X)%*%X)%*%t(X)
SSRg<- t(y)%*%( diag(1,nrow=n)  - Hg ) %*%y
sigma2 <- 1/rgamma(S, nu.st/2, (nu0*gamma_sq0 + SSRg)/2 )
# sample Beta | sigma^2
Vb<- g*solve(t(X)%*%X)/(g+1)
Eb<- Vb%*%t(X)%*%y
E<-matrix(rnorm(S*p,0,sqrt(sigma2)),S,p)
Beta<-t(  t(E%*%chol(Vb)) +c(Eb))
list(beta=Beta, s2=sigma2)
}
optimize_glm <- function(data=X, response=Y){
M2 <-as.matrix(X)
p0 <- ncol(data)
g <- nrow(data)
nu0 = 2
S = 10000
gamma_sq0 = 1
y.bar <- rep(1,n)*mean(Y)
for(m in 1:p0){
p <- length(M2[1,])
M2.post <-  lm.gprior(Y, M2, g, nu0, gamma_sq0, S)
M2.beta.hat <- colMeans(M2.post$beta)
R2.M2 <- 1 - (t(Y-M2%*%M2.beta.hat)%*%(Y-M2%*%M2.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF.max = 1 #set so max BF is always > 1
new.M2 = M2
for(covar in 2:p){
# set M1 as M2 w one covariate dropped
M1 <- M2[,-covar]
M1.post <- lm.gprior(Y, M1, g, nu0, gamma_sq0, S)
M1.beta.hat <- colMeans(M1.post$beta)
R2.M1 <- 1 - (t(Y-M1%*%M1.beta.hat)%*%(Y-M1%*%M1.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF = (log(1+g)*1/2) + ((n-1)/2)*(log(1+g*(1-R2.M2)) - log(1+g*(1-R2.M1)))
# if BF for M2 and M1 is greater than the current max BF, set this model as M2 for next iteration
if(BF > BF.max){
BF.max = BF
new.M2 = M1
}
}
# if none of the BF(M1, M2) calculated above are greater than 1, then the current M2 is the optimal model
if(BF.max == 1){
break
}
# otherwise, set M1 with max BF as the new M2
else{
M2 = new.M2
}
}
M2.beta.hat
}
sys.covariates <- sys.data.only %>%
select(-c("total_inmate_deaths"))
best.model <- optimize.glm(sys.covariates, sys.data.only$total_inmate_deaths)
lm.gprior <- function(y, X, g, nu0, gamma_sq0, S)
{
# sample new model
n = dim(X)[1]
p = dim(X)[2]
# sample sigma^2
nu.st = nu0 + n
Hg = (g/(g+1)) * X%*%solve(t(X)%*%X)%*%t(X)
SSRg<- t(y)%*%( diag(1,nrow=n)  - Hg ) %*%y
sigma2 <- 1/rgamma(S, nu.st/2, (nu0*gamma_sq0 + SSRg)/2 )
# sample Beta | sigma^2
Vb<- g*solve(t(X)%*%X)/(g+1)
Eb<- Vb%*%t(X)%*%y
E<-matrix(rnorm(S*p,0,sqrt(sigma2)),S,p)
Beta<-t(  t(E%*%chol(Vb)) +c(Eb))
list(beta=Beta, s2=sigma2)
}
optimize.glm <- function(data=X, response=Y){
M2 <-as.matrix(X)
p0 <- ncol(data)
g <- nrow(data)
nu0 = 2
S = 10000
gamma_sq0 = 1
y.bar <- rep(1,n)*mean(Y)
for(m in 1:p0){
p <- length(M2[1,])
M2.post <-  lm.gprior(Y, M2, g, nu0, gamma_sq0, S)
M2.beta.hat <- colMeans(M2.post$beta)
R2.M2 <- 1 - (t(Y-M2%*%M2.beta.hat)%*%(Y-M2%*%M2.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF.max = 1 #set so max BF is always > 1
new.M2 = M2
for(covar in 2:p){
# set M1 as M2 w one covariate dropped
M1 <- M2[,-covar]
M1.post <- lm.gprior(Y, M1, g, nu0, gamma_sq0, S)
M1.beta.hat <- colMeans(M1.post$beta)
R2.M1 <- 1 - (t(Y-M1%*%M1.beta.hat)%*%(Y-M1%*%M1.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF = (log(1+g)*1/2) + ((n-1)/2)*(log(1+g*(1-R2.M2)) - log(1+g*(1-R2.M1)))
# if BF for M2 and M1 is greater than the current max BF, set this model as M2 for next iteration
if(BF > BF.max){
BF.max = BF
new.M2 = M1
}
}
# if none of the BF(M1, M2) calculated above are greater than 1, then the current M2 is the optimal model
if(BF.max == 1){
break
}
# otherwise, set M1 with max BF as the new M2
else{
M2 = new.M2
}
}
M2.beta.hat
}
sys.covariates <- sys.data.only %>%
select(-c("total_inmate_deaths"))
best.model <- optimize.glm(sys.covariates, sys.data.only$total_inmate_deaths)
sys.covariates <- sys.data.only %>%
select(-c("total_inmate_deaths"))
best.model <- optimize.glm(data=sys.covariates, response=sys.data.only$total_inmate_deaths)
lm.gprior <- function(y, X, g, nu0, gamma_sq0, S)
{
# sample new model
n = dim(X)[1]
p = dim(X)[2]
# sample sigma^2
nu.st = nu0 + n
Hg = (g/(g+1)) * X%*%solve(t(X)%*%X)%*%t(X)
SSRg<- t(y)%*%( diag(1,nrow=n)  - Hg ) %*%y
sigma2 <- 1/rgamma(S, nu.st/2, (nu0*gamma_sq0 + SSRg)/2 )
# sample Beta | sigma^2
Vb<- g*solve(t(X)%*%X)/(g+1)
Eb<- Vb%*%t(X)%*%y
E<-matrix(rnorm(S*p,0,sqrt(sigma2)),S,p)
Beta<-t(  t(E%*%chol(Vb)) +c(Eb))
list(beta=Beta, s2=sigma2)
}
optimize.glm <- function(X, Y){
M2 <-as.matrix(X)
p0 <- ncol(data)
g <- nrow(data)
nu0 = 2
S = 10000
gamma_sq0 = 1
y.bar <- rep(1,n)*mean(Y)
for(m in 1:p0){
p <- length(M2[1,])
M2.post <-  lm.gprior(Y, M2, g, nu0, gamma_sq0, S)
M2.beta.hat <- colMeans(M2.post$beta)
R2.M2 <- 1 - (t(Y-M2%*%M2.beta.hat)%*%(Y-M2%*%M2.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF.max = 1 #set so max BF is always > 1
new.M2 = M2
for(covar in 2:p){
# set M1 as M2 w one covariate dropped
M1 <- M2[,-covar]
M1.post <- lm.gprior(Y, M1, g, nu0, gamma_sq0, S)
M1.beta.hat <- colMeans(M1.post$beta)
R2.M1 <- 1 - (t(Y-M1%*%M1.beta.hat)%*%(Y-M1%*%M1.beta.hat)) / (t(Y-y.bar)%*%(Y-y.bar))
BF = (log(1+g)*1/2) + ((n-1)/2)*(log(1+g*(1-R2.M2)) - log(1+g*(1-R2.M1)))
# if BF for M2 and M1 is greater than the current max BF, set this model as M2 for next iteration
if(BF > BF.max){
BF.max = BF
new.M2 = M1
}
}
# if none of the BF(M1, M2) calculated above are greater than 1, then the current M2 is the optimal model
if(BF.max == 1){
break
}
# otherwise, set M1 with max BF as the new M2
else{
M2 = new.M2
}
}
M2.beta.hat
}
sys.covariates <- sys.data.only %>%
select(-c("total_inmate_deaths"))
best.model <- optimize.glm(X=sys.covariates, Y=sys.data.only$total_inmate_deaths)
